学习笔记

SIMD
SIMD全称Single Instruction Multiple Data，单指令多数据流，能够复制多个操作数，并把它们打包在大型寄存器的一组指令集。

simd 大的寄存器 一次算八个

并行用SIMD,不要上来就并行

SIMD 实现方式：OpenMp
Directory 是一种注释

机器学习底层优化特别多

机器学习经常要做很多的预处理，找不到问题复杂度在哪
模型跑十万个样本要十分钟左右，猜可能是模型，模型用了三个light GBM

Sk-learn 很多实现超级低效

lightGBM实现了 random forest 同样的功能：
选择boost是RM,跟random forest 是一样的，不要用random forest

GPU不擅长if else 树模型 if else 多，lightGBM数据集非常大的情况下加速不明显

Go 语言功能性比较好，比java差，在机器学习方面不强。
python的生态圈里，可以扩展学Cython

python 代码不好保护，不是编译型语言。部署的时候不能把代码给别人。
甚至java 也不能完全保护代码。

解决办法 是用Cython ,Cython 编译后是C或者是C++，C++编译之后是.so文件，如果不加debug信息 就是汇编语言，别人是读不懂的。

代码混淆 不好修复问题，隐晦的问题，自己也修复不了

最接近数组的是numpy 矩阵运算库

# 编译Cython pyx 文件，编译成.cpp 再编译成C语言，但是自动删除了 .cpp只剩下.so文件。

$ python setup.py install 

如果想看到编译结果.cpp文件，则

$python setup.py build_ext -i 

C++ 优化 O1 O2 O3

Cython 做数据预处理，复杂度运算放在C里边，引用头文件

C++ 中不能用bool ,bool 只占一个bit ,在for循环当中，不同的编译器会出错。
如果用 bint 或者直接使用int =0 /1 

内存是瓶颈的时候 Cython没有用。

Cdef 和 Cpdef 

Cpdef 是python 和 Cython 中都能使用
什么时候使用 cdef 和 cpdef 函数？

一旦函数被调用，那么 cdef 和 def 函数内部代码的运行速度没有区别。
因此我们仅在以下条件下使用 cdef 函数：
	1. 
需要传递非Python类型
	2. 
需要传递它作为一个函数指针到C
	3. 
需要经常调用（加速函数调用很重要）而且不需要从Python调用


使用 cpdef 函数的条件：
	1. 
需要经常调用（所以使用加速函数调用很重要）而且需要从Python调用



Openmp 或者Eigen

实现各种各样并行加速的，只要在代码中加注释实现。
c++ 的class支持不好，如果想使用openmp最好用纯C来写。


Cython 可以绕过GIL限制，虽有有一些限制，但是可以实现，python 的全局解释器锁，强制你进行单线程，除非你使用多进程，多线程只有IO,python 多进程会复制好多份数据爆内存。



Python性能调优下

Cython  主要两个用途

1、一种是直接当成C用（简洁的C），把主要的逻辑功能都在python中写，好处是写的是python代码，但是它的效率比较高，要求是想达到的效率比较高，那么就需要把这里面的类定义好。

2、数据的预处理在Cython中处理，把pointer扔给C程序。


需要注意内存的资源分配问题，在C当中要手动的分配资源，如果要保存结果传数据的话，先要把资源一块在Cython中处理好，然后传给C,如果在C当中有临时的变量，那么在C当中分配完之后，要在C当中就把临时变量删掉，不可以在C当中分配完，在Cython当中删掉。

python 和 java 不需要关心内存泄漏的问题。

fortran 为列存储，C语言默认是行存储，尽量让目标操作在内存里连续，根据具体需求来确定行优先还是列优先

Python 自带的multiprocessing不建议使用

多线程
能不用多线程就不用多线程，只要用C写了，比多线程快多了。
Import ray

@ray.remote
def()
ray.init()
ray.put()之后返回的数据是并行共享的，但是不能修改，是只读的。

注意的问题：ray共享的数据不让写的原因是 race condition （竞态）,如果多个线程都在同时修改一个变量的数据，a线程先要读到寄存器才能改，另外一个线程也读取，每个线程都加1，比如现在是0，一块写的时候，线程a读完加1写回去等于1，线程2读取完1+1=2，但是有时会出现，同时并行的，这时造成结果可能是a读取到寄存器，没加完的时候，b线程就读取了0+1也等于1，两个结果就等于加了一个1，结果会出现错误，少加了。

race condition 这个问题，是不要让这种情况发生，而不是解决它。虽然功能受到限制，但是用起来起码不出事。机器学习的很多场景是需要同时写的，所以使用ray很少。

避免的场景

如有一个长数组，现在有100w个数据，把其分出来给4个线程去加，每个线程不要让他写到一个结果来，把他分别写到4处，自己加自己的，变成四维数组，最后单独组成把四个线程的结果再加一下。

虚拟环境安装line_profiler
